"""
Heat Equation Solver Visualization
==================================

This module provides utilities for analyzing and visualizing 
the numerical solution of the 1D heat equation using three 
time-integration schemes:

- Forward Euler (FE)
- Backward Euler (BE)
- Crank--Nicolson (CN)

The numerical data is produced by the C++ framework, which writes results to `.dat` files. 
This Python script does not perform the numerical time integration itself. 
Instead, it loads the solver outputs, compares them to the exact solution, and generates plots.

For demonstration purposes (see `main.cpp`), we consider the 1D heat equation

    u_t = alpha * u_xx

with diffusion coefficient `alpha = 1.0` and spatial domain x âˆˆ [0, 1].  
We enforce Dirichlet boundary conditions u(0, t) = 0 and u(1, t) = 0, and the initial condition

    u(x, 0) = sin(pi * x).

Under these assumptions the exact solution is given by

    u(x, t) = exp(-alpha * pi^2 * t) * sin(pi * x).

This Python script loads the output files generated by the C++ code, compares 
the numerical results against the exact solution, and creates plots for visualization. 

Main components
---------------
- Parameters: Dataclass storing simulation settings (dt, alpha, Nx, T).
- load_solver_data: Load numerical results from solver output files and compute analytical reference solution.
- plot_simulation: Plot numerical vs exact solution at multiple intermediate times for a chosen solver.
- plot_simulation_final_time: Plot numerical vs exact solution for all solvers at the final simulation time.

Example
-------
    >>> p = Parameters()
    >>> plot_simulation_final_time(parameters=p)
    >>> plot_simulation(solver="cn", parameters=p)
"""

from typing import List, Tuple, Union
import numpy as np
import matplotlib.pyplot as plt
import glob
import re

from dataclasses import dataclass, field

@dataclass
class Parameters:
    """
    Dataclass for storing simulation parameters for the 1D heat equation.

    Make sure that these correspond to the parameters in the C++ simulator. 

    Attributes:
        dt (float): Time step size. Default is 0.0001.
        alpha (float): The diffusion coefficient of the 1D heat equation. Default is 1.0.
        Nx (int): Number of spatial intervals (grid points = Nx + 1). Default is 50.
        T (float): Final simulation time. Default is 0.1.
        x (np.ndarray): Spatial grid, initialized after instantiation.
        Nt (int): Number of time steps (computed from T and dt).
        save_steps (List[int]): Time steps at which to save solutions (0, midpoint, final).
    """
    dt: float = 0.0001
    alpha: float = 1.0
    Nx: int = 50
    T: float = 0.1

    x: np.ndarray = field(init=False)
    Nt: int = field(init=False)
    save_steps: List[int] = field(init=False)

    def __post_init__(self):
        """
        Initialize spatial grid, number of time steps, and save points.
        """
        self.x = np.linspace(0, 1, self.Nx + 1)
        self.Nt = int(self.T / self.dt)
        self.save_steps = [0, self.Nt // 2, self.Nt]

def load_solver_data(
    solver: str, 
    parameters: Parameters, 
    final: bool = False
) -> Union[ 
        List[str],
        Tuple[np.ndarray, np.ndarray, np.ndarray, float]
    ]:
    """
    Loads output files generated by the C++ solver and (if applicable) compute the exact solution.

    Args:
        solver (str): Solver identifier ("fe", "be", "cn").
        parameters (Parameters): Dataclass storing the simulation parameters
        final (bool): 
            If False: return list of snapshot filenames for the chosen solver.
            If True: load final-time data file and return numerical + exact solution.
    
    Returns:
        If final == False:
            List[str]: Sorted list of filenames for the requested solver and save steps.

        If final == True:
            Tuple[np.ndarray, np.ndarray, np.ndarray, float]:
                (x, u_numeric, u_exact, t)
                - x: spatial grid from file
                - u_numeric: numerical solution at time t
                - u_exact: exact solution at time t (computed analytically)
                - t: final simulation time
    """
    if final: 
        # Load final-time .dat file
        filepath = f"example-outputs/simulation-final-time/Heat{solver.upper()}.dat"
        x, u_numeric = np.loadtxt(filepath, unpack=True)
        t = parameters.T
        u_exact = np.exp(-parameters.alpha * np.pi**2 * t) * np.sin(np.pi * parameters.x)
        
        return x, u_numeric, u_exact, t
    else:
        # Load time snapshots
        suffix: str = f"Heat{solver.upper()}_step*"
        fpattern: str = f"example-outputs/full-simulation-{solver.upper()}/{suffix}"
        files = glob.glob(fpattern)
        fsorted: List = sorted(files, key=lambda f: int(re.search(r'step(\d+)\.dat', f).group(1)))
        fselected: List = [f for f in fsorted if int(re.search(r'step(\d+)\.dat', f).group(1)) in parameters.save_steps]

        return fselected

def plot_simulation(
    solver: str,
    parameters: Parameters,
    stride: int = 3
) -> None:
    """
    Plot numerical vs exact solution at selected time steps for a given solver.
    
    By default, this function plots the solution at three time instants:
        - the initial condition (t = 0), 
        - the midpoint of the simulation, 
        - the final time (t = T). 
        
    These points are determined by parameters.save_steps`.

    Args:
        solver (str): Solver identifier ("fe", "be", "cn"). 
        parameters (Parameters): Simulation parameters dataclass.
        stride (int): Stride factor for downsampling numerical solution when plotting (to avoid too many markers).
    """
    files_selected = load_solver_data(solver=solver, parameters=parameters, final=False)

    plt.figure(figsize=(15,5))

    for index, file in enumerate(files_selected):
        step_index: int = int(re.search(r'step(\d+)\.dat', file).group(1))
        t: float = step_index * parameters.dt

        # Numerical solution
        u_numeric = np.loadtxt(file)[:, 1]

        # Exact solution
        u_exact = np.exp(-parameters.alpha * np.pi**2 * t) * np.sin(np.pi * parameters.x)

        plt.subplot(1, 3, index+1)
        plt.plot(parameters.x, u_exact, 'r-', label='Exact')
        plt.plot(parameters.x[::stride], u_numeric[::stride], 'bo', markersize=4, label='Numerical')
        plt.xlabel('x')
        plt.ylabel('u(x, t)')
        plt.title(f"t = {t:.3f}")
        plt.ylim(0, 1.1)
        plt.grid(True)
        plt.legend()
    
    solver_names = {
        "fe": "Forward Euler",
        "be": "Backward Euler",
        "cn": "Crank--Nicolson"
    }

    plt.suptitle(f"1D Heat Equation: {solver_names.get(solver)} Numerical vs Exact Solution", fontsize=14)
    plt.tight_layout(rect=[0, 0, 1, 0.95])
    plt.show()   

def plot_simulation_final_time(parameters: Parameters) -> None:
    """
    Plot numerical vs exact solutions for all solvers (FE, BE, CN) at the final simulation time.

    Args:
        parameters (Parameters): Dataclass storing the simulation parameters
    """
    solvers = ["fe", "be", "cn"]
    solver_names = {
        "fe": "Forward Euler",
        "be": "Backward Euler",
        "cn": "Crank--Nicolson"
    }

    fig, axes = plt.subplots(1, 3, figsize=(16, 6), sharex=True, sharey=True)

    for index, solver in enumerate(solvers):
        x, u_numeric, u_exact, t = load_solver_data(solver=solver, parameters=parameters, final=True)

        axes[index].plot(x, u_numeric, 'o', markersize=4, label=solver_names.get(solver))
        axes[index].plot(parameters.x, u_exact, 'r-', label='Exact')
        axes[index].set_title(solver_names.get(solver))
        axes[index].set_xlabel("x")
        axes[index].set_ylabel("u(x, T)")
        axes[index].legend()
        axes[index].grid(True)
    
    fig.suptitle(f"1D Heat Equation at Final Time t = {parameters.T:.3f}", fontsize=14)
    plt.tight_layout(rect=[0, 0, 1, 0.95])
    plt.show()

p = Parameters()
plot_simulation_final_time(parameters=p)
plot_simulation(solver="cn", parameters=p)